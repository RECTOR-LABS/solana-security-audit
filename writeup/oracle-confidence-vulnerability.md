# SPL Token-Lending: Missing Pyth Oracle Confidence Interval Validation

## Summary

The SPL token-lending program's `get_pyth_price()` function reads the aggregate price from Pyth oracle accounts but completely ignores the confidence interval (`pyth_price.agg.conf`). This violates Pyth's documented integration best practices and allows the protocol to accept unreliable oracle prices during periods of extreme market volatility, enabling undercollateralized borrowing.

## Severity

**High** — Direct financial loss through protocol undercollateralization.

## Affected Code

**File:** `token-lending/program/src/processor.rs`
**Function:** `get_pyth_price()` (line 1803)

```rust
fn get_pyth_price(pyth_price_info: &AccountInfo, clock: &Clock) -> Result<Decimal, ProgramError> {
    // ... validates price type, trading status, staleness ...

    let price: u64 = pyth_price.agg.price.try_into().map_err(|_| {
        msg!("Oracle price cannot be negative");
        LendingError::InvalidOracleConfig
    })?;

    // BUG: pyth_price.agg.conf is NEVER checked.
    // The confidence interval is completely ignored.

    let market_price = if pyth_price.expo >= 0 { ... } else { ... };
    Ok(market_price)
}
```

The function validates:
- Price type (`ptype == PriceType::Price`)
- Trading status (`agg.status == PriceStatus::Trading`)
- Staleness (`slots_elapsed < 5`)
- Non-negative price (`agg.price >= 0`)

But does NOT validate:
- **Confidence interval** (`agg.conf`) — completely ignored

## Pyth Confidence Interval

Pyth oracle prices include a confidence interval (`conf`) representing the uncertainty in the aggregate price. Per [Pyth's integration best practices](https://docs.pyth.network/price-feeds/best-practices#confidence-intervals):

> "Pyth publishes a confidence interval because, in real markets, there is no single price for a product... Protocols should use the confidence interval to protect their users from these situations."

The confidence value represents a 1-sigma standard deviation. A `conf` of $2 on a $100 price means there's ~68% probability the true price is between $98 and $102.

## Attack Scenario

1. **Volatile Market Conditions**: During a flash crash, liquidation cascade, or exchange outage, Pyth's confidence interval widens significantly (e.g., `conf` becomes 20-50% of price).

2. **Attacker Deposits Collateral**: The attacker deposits an asset whose oracle price is inflated relative to reality. With `price = $100` and `conf = $50`, the true price could be as low as $50, but the lending program uses $100.

3. **Borrow Against Inflated Value**: The attacker borrows the maximum allowed by the LTV ratio against the inflated collateral valuation.

4. **Price Resolves Lower**: When volatility subsides and the oracle price corrects to the true value, the position becomes undercollateralized. The attacker keeps the borrowed funds; the protocol absorbs the loss.

### Concrete Example

- SOL oracle: `price = $20`, `conf = $10` (50% uncertainty)
- True SOL price: $12 (within the confidence band)
- Attacker deposits 1000 SOL as collateral
- Protocol values collateral at: 1000 * $20 = $20,000
- With 80% LTV, attacker borrows: $16,000 USDC
- True collateral value: 1000 * $12 = $12,000
- **Protocol loss: $4,000** (attacker is $4,000 undercollateralized)

## Impact

- **Direct financial loss**: Undercollateralized positions drain protocol reserves
- **Cascading liquidations**: Bad debt from exploited positions can trigger further liquidations
- **Reference implementation risk**: SPL token-lending is the canonical Solana lending implementation; forks inheriting this code are equally vulnerable
- **Exploitable during natural volatility**: Does not require oracle manipulation — naturally occurring market events trigger wide confidence intervals

## Proof of Concept

See `token-lending/program/tests/pyth_oracle_confidence.rs`:

- `test_refresh_reserve_rejects_wide_confidence`: Creates a Pyth oracle with `conf = 50%` of price, demonstrates that `refresh_reserve` rejects it after the fix
- `test_refresh_reserve_accepts_narrow_confidence`: Verifies that oracles with `conf = 1%` continue to work normally
- `test_refresh_reserve_accepts_boundary_confidence`: Verifies the 5% threshold boundary behavior

## Fix

**File:** `token-lending/program/src/processor.rs`, function `get_pyth_price()`

Add a confidence interval validation after the price is extracted:

```rust
// Maximum confidence interval as a percentage of price.
// Reject oracle prices where conf / price > 5%.
const MAX_CONFIDENCE_PERCENTAGE: u64 = 5;

// ... after extracting price ...

let conf = pyth_price.agg.conf;
if price > 0 {
    let max_conf = price
        .checked_mul(MAX_CONFIDENCE_PERCENTAGE)
        .ok_or(LendingError::MathOverflow)?
        / 100;
    if conf > max_conf {
        msg!("Oracle confidence interval too wide: conf={}, price={}", conf, price);
        return Err(LendingError::InvalidOracleConfig.into());
    }
}
```

The 5% threshold is consistent with other Solana DeFi protocols (Mango Markets uses 10%, Drift Protocol uses dynamic bands). The check is placed after the staleness validation and before the price conversion to `Decimal`, ensuring early rejection.

## Fix Characteristics

- **Minimal diff**: ~10 lines added to a single function
- **No state changes**: No account layout or instruction changes
- **No new dependencies**: Uses existing `LendingError::InvalidOracleConfig`
- **Backward compatible**: Only rejects previously-accepted unreliable prices
- **Configurable threshold**: The constant can be adjusted per deployment needs

## References

- [Pyth Best Practices: Confidence Intervals](https://docs.pyth.network/price-feeds/best-practices#confidence-intervals)
- [Mango Markets oracle confidence check](https://github.com/blockworks-foundation/mango-v3/blob/main/program/src/state.rs) — validates `conf * 10 > price`
- [OpenBook v2 `has_valid_confidence()`](https://github.com/openbook-dex/openbook-v2/blob/master/programs/openbook-v2/src/state/oracle.rs)
